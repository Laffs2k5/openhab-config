// Imports
import java.util.HashMap                        //
import org.eclipse.xtext.xbase.lib.Functions    // Needed for use of lambda
import java.util.concurrent.locks.ReentrantLock // Needed to block rules from triggering in paralell
import java.util.concurrent.TimeUnit            //

// Constants
val String LOGGER_NAME = "cmpterRoom"
val String IR_MAPFILE = "broadlink.map"

// Scene control commands
val int CONTROL_SCENE_NOCHANGE   = -1
val int CONTROL_SCENE_ALLOFF     = 0  // Turn off receiver + TV
val int CONTROL_SCENE_CHROMECAST = 1  // Turn off receiver + TV and set to chromecast input
val int CONTROL_SCENE_COMPUTER   = 2  // Turn off receiver + TV and set to chromecast input

// Common control commands
val String CONTROL_NOCHANGE = "CONTROL_NOCHANGE"  // do nothing

// TV control commands to commands definition (ir command name and time the ir command takes to transmit)
val HashMap<String, HashMap<String,String>> g_tvCommands = newHashMap(
     "CONTROL_TV_VOL_MINUS"   ->  (newHashMap("irCommand" ->  "SONY_W5500_VOLUME_DOWN_X3",      "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_TV_VOL_PLUS"    ->  (newHashMap("irCommand" ->  "SONY_W5500_VOLUME_UP_X3",        "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_TV_VOL_MUTE"    ->  (newHashMap("irCommand" ->  "SONY_W5500_MUTE_TOGGLE_X5",      "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_TV_VOL_MINUS70" ->  (newHashMap("irCommand" ->  "SONY_W5500_VOLUME_DOWN_X155",    "irTransmitTimeMs" ->  "7000"))
    ,"CONTROL_TV_VOL_PLUS70"  ->  (newHashMap("irCommand" ->  "SONY_W5500_VOLUME_UP_X155",      "irTransmitTimeMs" ->  "7000"))
    ,"CONTROL_TV_DISP_THMODE" ->  (newHashMap("irCommand" ->  "SONY_W5500_THEATER_MODE_X5",     "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_TV_DIGIT_1"     ->  (newHashMap("irCommand" ->  "SONY_W5500_DIGIT_1_X5",          "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_TV_INPUT_HDMI1" ->  (newHashMap("irCommand" ->  "SONY_W5500_INPUT_HDMI_1_X5",     "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_TV_INPUT_HDMI3" ->  (newHashMap("irCommand" ->  "SONY_W5500_INPUT_HDMI_3_X5",     "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_TV_INPUT_HDMI4" ->  (newHashMap("irCommand" ->  "SONY_W5500_INPUT_HDMI_4_X5",     "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_TV_POWER_ON"    ->  (newHashMap("irCommand" ->  "SONY_W5500_POWER_ON_X5",         "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_TV_POWER_OFF"   ->  (newHashMap("irCommand" ->  "SONY_W5500_POWER_OFF_X5",        "irTransmitTimeMs" ->  "100"))
)


// Special audio control commands
//  These requires more action than just issuing an IR command
val String CONTROL_AUDIO_POWER_ON = "CONTROL_AUDIO_POWER_ON"
val String CONTROL_AUDIO_POWER_OFF = "CONTROL_AUDIO_POWER_OFF"

// Audio control commands to commands definition (ir command name and time the ir command takes to transmit)
val HashMap<String, HashMap<String,String>> g_audioCommands = newHashMap(
     "CONTROL_AUDIO_VOL_MINUS"          ->  (newHashMap("irCommand" ->  "LOGITECH_Z5500_VOLUMEDOWN_X2",         "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_AUDIO_VOL_PLUS"           ->  (newHashMap("irCommand" ->  "LOGITECH_Z5500_VOLUMEUP_X2",           "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_AUDIO_VOL_DEF_CC"         ->  (newHashMap("irCommand" ->  "LOGITECH_Z5500_VOLUMEUP_X13",          "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_AUDIO_VOL_DEF_COMPUTER"   ->  (newHashMap("irCommand" ->  "LOGITECH_Z5500_VOLUMEUP_X18",          "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_AUDIO_VOL_ZERO"           ->  (newHashMap("irCommand" ->  "LOGITECH_Z5500_VOLUME_BURST_TO_ZERO",  "irTransmitTimeMs" ->  "7000"))
    ,"CONTROL_AUDIO_VOL_MAX"            ->  (newHashMap("irCommand" ->  "LOGITECH_Z5500_VOLUME_BURST_TO_MAX",   "irTransmitTimeMs" ->  "7000"))
    ,"CONTROL_AUDIO_VOL_MUTE"           ->  (newHashMap("irCommand" ->  "LOGITECH_Z5500_MUTE",                  "irTransmitTimeMs" ->  "100"))
    ,"CONTROL_AUDIO_INPUT_COAX"         ->  (newHashMap("irCommand" ->  "LOGITECH_Z5500_SOURCE_COAX_X2",        "irTransmitTimeMs" ->  "1500"))
    ,"CONTROL_AUDIO_INPUT_DIRECT"       ->  (newHashMap("irCommand" ->  "LOGITECH_Z5500_SOURCE_DIRECT_X2",      "irTransmitTimeMs" ->  "1500"))
    ,"CONTROL_AUDIO_INPUT_OPTICAL"      ->  (newHashMap("irCommand" ->  "LOGITECH_Z5500_SOURCE_OPTICAL_X2",     "irTransmitTimeMs" ->  "1500"))
    ,"CONTROL_AUDIO_POWER_TOGGLE"       ->  (newHashMap("irCommand" ->  "LOGITECH_Z5500_POWER_X4",              "irTransmitTimeMs" ->  "1500"))
)

// Globals
var ReentrantLock   g_computerRoomLockIrCommands = new ReentrantLock()
var ReentrantLock   g_computerRoomLockTvUpdates = new ReentrantLock()
//var ReentrantLock   g_computerRoomLockScenesUpdates = new ReentrantLock()
var ReentrantLock   g_computerRoomLockReceiverUpdates = new ReentrantLock()

// Lambdas
val Functions$Function2<String, GenericItem, Boolean> logReceivedUpdateWithState = [
    loggerName,
    itemUpdated |
    val String LOGGER = loggerName //+ ".logReceivedUpdateWithState"
    logInfo(LOGGER, "Item '{}' received update '{}'",
        itemUpdated.name,
        itemUpdated.state)
    true
]
/*
val Functions$Function4<String, String, String, GenericItem, Boolean> postIrCommandToItem = [
    loggerName,
    irMapfile,
    irCommand,
    IrBlasterItem |
    val String LOGGER = loggerName + ".postIrCmd"
    logDebug(LOGGER, "Transforming IR command '{}' using map file '{}'", irCommand, irMapfile)
    val cmd = transform("MAP", irMapfile, irCommand)
    logDebug(LOGGER, "Transformed command: {}", cmd)
    logDebug(LOGGER, "Posting command '{}' to item '{}'",irCommand, IrBlasterItem.name)
    IrBlasterItem.sendCommand(irCommand)
    true
]
*/
/*
val Functions$Function6<String, String, String, ReentrantLock, Integer, GenericItem, Boolean> postIrCommandToItemWithLockAndWait = [
    loggerName,
    irMapfile,
    irCommand,
    irCommandLock,
    irCommandBlockTime,
    IrBlasterItem |
    val String LOGGER = loggerName + ".postIrCmdWLock"
    logDebug(LOGGER, "Transforming IR command '{}' using map file '{}'", irCommand, irMapfile)
    val cmd = transform("MAP", irMapfile, irCommand)
    logDebug(LOGGER, "Transformed command: {}", cmd)

    logDebug(LOGGER, "Aquire lock...")
    irCommandLock.lock()
    try {
        logDebug(LOGGER, "Lock aquired.")
        logDebug(LOGGER, "Posting command '{}' to item '{}'", irCommand, IrBlasterItem.name)
        IrBlasterItem.sendCommand(irCommand)
        Thread::sleep(irCommandBlockTime)
    } catch(Throwable t) {
        logError(LOGGER, "Exception caught while posting ir command. Exception was: {}", t.toString())
    } finally {
        irCommandLock.unlock()
        logDebug(LOGGER, "Lock released.")
    }
    true
]
val Functions$Function1<HashMap<String,String>, String> getIrCommandFromDef = [
    irCommandDef |
    return irCommandDef.get("irCommand")
]
val Functions$Function1<HashMap<String,String>, Integer> getIrTransmitTimeFromDef = [
    irCommandDef |
    return Integer.parseInt(irCommandDef.get("irTransmitTimeMs"))
]
*/

// Utility function
// Post given ir command code to given IR blaster
// Use given lock to make sure all calls to this function is executed in order
val Functions$Function5<String, String, ReentrantLock, HashMap<String, HashMap<String,String>>, GenericItem, Boolean> transmitIrCommand = [
    loggerName,
    irCommandCode,
    irCommandLock,
    irCommandsMap,
    IrBlasterItem |

    // Constants
    val String LOGGER = loggerName + ".postIrCmdWLock"
    val String IR_MAPFILE = "broadlink.map"
    val String IR_DEF_CMD_KEY = "irCommand"
    val String IR_DEF_TRANSMIT_TIME_KEY = "irTransmitTimeMs"

    logInfo(LOGGER, "Going to transmit IR command code '{}'.", irCommandCode)

    // Vars
    val HashMap<String,String> irCommandDef = new HashMap<String,String>(irCommandsMap.get(irCommandCode))
    val String irCommand = irCommandDef.get(IR_DEF_CMD_KEY)
    val Integer irTransmitTime = Integer.parseInt(irCommandDef.get(IR_DEF_TRANSMIT_TIME_KEY))

    logInfo(LOGGER, "IR command code {} corresponds to ir command named {} with transmit time of {} ms", irCommandCode, irCommand, irTransmitTime)

    // Just for debug
    //logInfo(LOGGER, "Transforming IR command '{}' using map file '{}' to raw IR command.", irCommand, IR_MAPFILE)
    //val irRawCommand = transform("MAP", IR_MAPFILE, irCommand)
    //logInfo(LOGGER, "Raw IR command is: {}", irRawCommand)

    logInfo(LOGGER, "Waiting for lock...") // makes sure only one IR command is issued at a time
    irCommandLock.lock()
    try {
        logInfo(LOGGER, "Lock aquired.")
        logInfo(LOGGER, "Posting command '{}' to item '{}'", irCommand, IrBlasterItem.name)
        IrBlasterItem.sendCommand(irCommand)
        Thread::sleep(irTransmitTime)
    } catch(Throwable t) {
        logError(LOGGER, "Exception caught while posting ir command. Exception was: {}", t.toString())
    } finally {
        irCommandLock.unlock()
        logInfo(LOGGER, "Lock released.")
    }

    true
]

// Handle echo items
rule "Computer room scene, echo item update, chromecast"
when
    Item Echo_Scene_GF_ComputerRoom_Chromecast received update ON
then
    val String LOGGER = LOGGER_NAME + ".echoSceneCc"
    logReceivedUpdateWithState.apply(LOGGER, (triggeringItem as GenericItem))
    ComputerRoom_IrBlaster_scenes_control.sendCommand(CONTROL_SCENE_CHROMECAST)
    triggeringItem.postUpdate(OnOffType::OFF)
end
rule "Computer room scene, echo item update, computer"
when
    Item Echo_Scene_GF_ComputerRoom_Computer received update ON
then
    val String LOGGER = LOGGER_NAME + ".echoSceneComputer"
    logReceivedUpdateWithState.apply(LOGGER, (triggeringItem as GenericItem))
    ComputerRoom_IrBlaster_scenes_control.sendCommand(CONTROL_SCENE_COMPUTER)
    triggeringItem.postUpdate(OnOffType::OFF)
end
rule "Computer room scene, echo item update, all off"
when
    Item Echo_Scene_GF_ComputerRoom_AllOff received update ON
then
    val String LOGGER = LOGGER_NAME + ".echoSceneAllOff"
    logReceivedUpdateWithState.apply(LOGGER, (triggeringItem as GenericItem))
    ComputerRoom_IrBlaster_scenes_control.sendCommand(CONTROL_SCENE_ALLOFF)
    triggeringItem.postUpdate(OnOffType::OFF)
end

// When the Computer room IR blaster scenes control element receives update
//  Issue associated commands
//  Reset UI element to non-pressed state
rule "Computer room IR, scenes control command"
when
    Item ComputerRoom_IrBlaster_scenes_control received update
then
    val String LOGGER = LOGGER_NAME + ".sceneCtl"
    logReceivedUpdateWithState.apply(LOGGER, (triggeringItem as GenericItem))

    val GenericItem IrBlasterItem = IR_GF_ComputerRoom_Broadlink_RM3Mini_command
    //val StringItem TvControlItem = ComputerRoom_IrBlaster_TV_control
    val StringItem AudioControlItem = ComputerRoom_IrBlaster_Audio_control
    val SwitchItem dimDownItem = ComputerRoom_TvBacklight_DimDown_trigger
    val SwitchItem dimUpItem = ComputerRoom_TvBacklight_DimUp_trigger

    val HashMap<String, HashMap<String,String>> tvIrCommandsMap = new HashMap<String, HashMap<String,String>>(g_tvCommands)
    val HashMap<String, HashMap<String,String>> audioIrCommandsMap = new HashMap<String, HashMap<String,String>>(g_audioCommands)

    val NumberItem ControlItem = (triggeringItem as NumberItem)
    val int receivedCommand = (ControlItem.state as DecimalType).intValue
    logInfo(LOGGER, "Scenes control received command code {}.", receivedCommand)
    if( receivedCommand != CONTROL_SCENE_NOCHANGE ) {

// TODO need som kind of lock for this, one at a time

        switch receivedCommand {
            case CONTROL_SCENE_ALLOFF: {
                logInfo(LOGGER, "Received all off scene command")

                // Dim down tv backlight
                dimDownItem.postUpdate(OnOffType::ON)

                // Turn off tv
                //TvControlItem.sendCommand("CONTROL_TV_POWER_OFF")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_POWER_OFF", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)

                // Turn off receiver
                //AudioControlItem.sendCommand("CONTROL_AUDIO_VOL_ZERO")      // to mininmize noise during power off
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_VOL_ZERO", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)
                //AudioControlItem.sendCommand("CONTROL_AUDIO_POWER_TOGGLE")  // to mininmize noise during power off
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_POWER_TOGGLE", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)
                //Thread::sleep(4000)
                AudioControlItem.sendCommand("CONTROL_AUDIO_POWER_OFF")

            }
            case CONTROL_SCENE_CHROMECAST: {
                logInfo(LOGGER, "Received chromecast scene command")

                // In case recveiver is on, turn volume down
                //AudioControlItem.sendCommand("CONTROL_AUDIO_VOL_ZERO")
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_VOL_ZERO", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)

                // Dim up tv backlight
                dimUpItem.postUpdate(OnOffType::ON)

                // Tv
                //TvControlItem.sendCommand("CONTROL_TV_POWER_ON")
                //TvControlItem.sendCommand("CONTROL_TV_DIGIT_1")
                //TvControlItem.sendCommand("CONTROL_TV_DIGIT_1")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_DIGIT_1", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                Thread::sleep(5000) // extra wait in case tv was powered down

                //TvControlItem.sendCommand("CONTROL_TV_VOL_MUTE")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_VOL_MUTE", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                //Thread::sleep(1000)
                //TvControlItem.sendCommand("CONTROL_TV_VOL_MINUS70")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_VOL_MINUS70", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                //Thread::sleep(7000)
                //TvControlItem.sendCommand("CONTROL_TV_VOL_PLUS")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_VOL_PLUS", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                //Thread::sleep(500)
                //TvControlItem.sendCommand("CONTROL_TV_VOL_MINUS")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_VOL_MINUS", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                //Thread::sleep(500)
                //TvControlItem.sendCommand("CONTROL_TV_INPUT_HDMI3")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_INPUT_HDMI3", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                //Thread::sleep(5000)

                // Receiver
                //Thread::sleep(8000) // wait for tv commands to complete and ir blaster to be availble
                AudioControlItem.sendCommand("CONTROL_AUDIO_POWER_ON")
                logInfo(LOGGER,"Call power on")
                Thread::sleep(2000) // wait for power on sequence to get started, takes up to 8500 to complete
                logInfo(LOGGER,"Start wait for power on")
                try {
                    // Wait until power on sequence completes
                    g_computerRoomLockReceiverUpdates.tryLock(15,TimeUnit.SECONDS)
                    logInfo(LOGGER,"Power on lock aquired")
                } catch(Throwable t) {
                    logInfo(LOGGER,"Wait for power on failed")
                    logError(LOGGER, "Exception caught when attempting to wait for receiver power toggle. Exception was: {}", t.toString())
                }
                finally {
                    g_computerRoomLockReceiverUpdates.unlock()
                    logInfo(LOGGER,"Power on lock released")
                }
                logInfo(LOGGER,"Done wait for power on")
                //Thread::sleep(3500)

                //AudioControlItem.sendCommand("CONTROL_AUDIO_INPUT_COAX")
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_INPUT_COAX", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)
                //Thread::sleep(3000)
                //AudioControlItem.sendCommand("CONTROL_AUDIO_VOL_ZERO")
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_VOL_ZERO", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)
                //Thread::sleep(7000)
                //AudioControlItem.sendCommand("CONTROL_AUDIO_INPUT_OPTICAL")
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_INPUT_OPTICAL", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)
                //Thread::sleep(5000)
                //AudioControlItem.sendCommand("CONTROL_AUDIO_VOL_DEF_CC")
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_VOL_DEF_CC", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)
            }
            case CONTROL_SCENE_COMPUTER: {
                logInfo(LOGGER, "Received computer scene command")


                // In case recveiver is on, turn volume down
                //AudioControlItem.sendCommand("CONTROL_AUDIO_VOL_ZERO")
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_VOL_ZERO", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)

                // Dim up tv backlight
                dimUpItem.postUpdate(OnOffType::ON)

                // Tv
                //TvControlItem.sendCommand("CONTROL_TV_POWER_ON")
                //TvControlItem.sendCommand("CONTROL_TV_DIGIT_1")
                //TvControlItem.sendCommand("CONTROL_TV_DIGIT_1")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_DIGIT_1", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                Thread::sleep(5000) // extra wait in case tv was powered down

                //TvControlItem.sendCommand("CONTROL_TV_VOL_MUTE")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_VOL_MUTE", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                //Thread::sleep(1000)
                //TvControlItem.sendCommand("CONTROL_TV_VOL_MINUS70")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_VOL_MINUS70", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                //Thread::sleep(7000)
                //TvControlItem.sendCommand("CONTROL_TV_VOL_PLUS")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_VOL_PLUS", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                //Thread::sleep(500)
                //TvControlItem.sendCommand("CONTROL_TV_VOL_MINUS")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_VOL_MINUS", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                //Thread::sleep(500)
                //TvControlItem.sendCommand("CONTROL_TV_INPUT_HDMI3")
                transmitIrCommand.apply(LOGGER, "CONTROL_TV_INPUT_HDMI1", g_computerRoomLockIrCommands, tvIrCommandsMap, IrBlasterItem)
                //Thread::sleep(5000)

                // Receiver
                //Thread::sleep(8000) // wait for tv commands to complete and ir blaster to be availble
                AudioControlItem.sendCommand("CONTROL_AUDIO_POWER_ON")
                logInfo(LOGGER,"Call power on")
                Thread::sleep(2000) // wait for power on sequence to get started, takes up to 8500 to complete
                logInfo(LOGGER,"Start wait for power on")
                try {
                    // Wait until power on sequence completes
                    g_computerRoomLockReceiverUpdates.tryLock(15,TimeUnit.SECONDS)
                    logInfo(LOGGER,"Power on lock aquired")
                } catch(Throwable t) {
                    logInfo(LOGGER,"Wait for power on failed")
                    logError(LOGGER, "Exception caught when attempting to wait for receiver power toggle. Exception was: {}", t.toString())
                }
                finally {
                    g_computerRoomLockReceiverUpdates.unlock()
                    logInfo(LOGGER,"Power on lock released")
                }
                logInfo(LOGGER,"Done wait for power on")
                //Thread::sleep(3500)

                //AudioControlItem.sendCommand("CONTROL_AUDIO_INPUT_COAX")
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_INPUT_COAX", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)
                //Thread::sleep(3000)
                //AudioControlItem.sendCommand("CONTROL_AUDIO_VOL_ZERO")
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_VOL_ZERO", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)
                //Thread::sleep(7000)
                //AudioControlItem.sendCommand("CONTROL_AUDIO_INPUT_DIRECT")
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_INPUT_DIRECT", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)
                //Thread::sleep(5000)
                //AudioControlItem.sendCommand("CONTROL_AUDIO_VOL_DEF_COMPUTER")
                transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_VOL_DEF_COMPUTER", g_computerRoomLockIrCommands, audioIrCommandsMap, IrBlasterItem)
            }
            default:{
                logWarn(LOGGER, "Unexpected control signal {}", receivedCommand)
            }
        }

        // To prevent the UI showing button in "pressed" state
        ControlItem.postUpdate(CONTROL_SCENE_NOCHANGE)
    }
end

// When computer room TV Ir blaster control element receives update
//  Issue associated IR command
//  Reset UI element to non-pressed state
rule "Computer room IR, TV control command"
when
    Item ComputerRoom_IrBlaster_TV_control received update
then
    val String LOGGER = LOGGER_NAME + ".tvCtl"
    logReceivedUpdateWithState.apply(LOGGER, (triggeringItem as GenericItem))

    val GenericItem IrBlasterItem = IR_GF_ComputerRoom_Broadlink_RM3Mini_command
    val HashMap<String, HashMap<String,String>> irCommandsMap = new HashMap<String, HashMap<String,String>>(g_tvCommands)

    val StringItem ControlItem = (triggeringItem as StringItem)
    val String receivedCommand = ControlItem.state.toString()
    logInfo(LOGGER, "TV control received command code {}.", receivedCommand)
    if( receivedCommand != CONTROL_NOCHANGE ) {

        g_computerRoomLockTvUpdates.lock()
        try {
            /*
            val HashMap<String,String> irCommandDef = new HashMap<String,String>(irCommandsMap.get(receivedCommand))
            val String irCommand = getIrCommandFromDef.apply(irCommandDef)
            val Integer irTransmitTime = getIrTransmitTimeFromDef.apply(irCommandDef)
            logInfo(LOGGER, "TV command code {} corresponds to ir command named {} with transmit time of {} ms",receivedCommand,irCommand,irTransmitTime)
            postIrCommandToItemWithLockAndWait.apply(LOGGER, IR_MAPFILE, irCommand, g_computerRoomLockIrCommands, irTransmitTime, IrBlasterItem)
            */
            transmitIrCommand.apply(LOGGER, receivedCommand, g_computerRoomLockIrCommands, irCommandsMap, IrBlasterItem)
        } catch(Throwable t) {
            logError(LOGGER, "Exception caught when handling control command. The exception was: {}", t.toString())
        } finally {
            g_computerRoomLockTvUpdates.unlock()
        }

        // To prevent the UI showing button in "pressed" state
        ControlItem.postUpdate(CONTROL_NOCHANGE)
    }
end

// When computer room Audio Ir blaster control element receives update
//  Issue associated IR command
//  Reset UI element to non-pressed state
rule "Computer room IR, Audio control command"
when
    Item ComputerRoom_IrBlaster_Audio_control received update
then
    val String LOGGER = LOGGER_NAME + ".audioCtl"
    logReceivedUpdateWithState.apply(LOGGER, (triggeringItem as GenericItem))

    val GenericItem IrBlasterItem = IR_GF_ComputerRoom_Broadlink_RM3Mini_command
    val HashMap<String, HashMap<String,String>> irCommandsMap = new HashMap<String, HashMap<String,String>>(g_audioCommands)
    val SwitchItem ReceiverWallplugItem = Wallplug_GF_ComputerRoom_ReceiverPower_switch

    val StringItem ControlItem = (triggeringItem as StringItem)
    val String receivedCommand = ControlItem.state.toString()
    if( receivedCommand != CONTROL_NOCHANGE ) {
        // Some commands are not discrete IR commands
        switch receivedCommand {
            case CONTROL_AUDIO_POWER_ON: {
                logInfo(LOGGER, "Audio control received power ON command.")

                g_computerRoomLockReceiverUpdates.lock()
                try {
                    // Wallplug: Toggle power receiver
                    ReceiverWallplugItem.sendCommand(OnOffType::OFF)
                    Thread::sleep(2500)
                    ReceiverWallplugItem.sendCommand(OnOffType::ON)
                    Thread::sleep(4500)

                    // Turn on receiver by ir
                    /*
                    val HashMap<String,String> irCommandDef = new HashMap<String,String>(irCommandsMap.get("CONTROL_AUDIO_POWER_TOGGLE"))
                    val String irCommand = getIrCommandFromDef.apply(irCommandDef)
                    val Integer irTransmitTime = getIrTransmitTimeFromDef.apply(irCommandDef)
                    logInfo(LOGGER, "Sending audio command named {} with transmit time of {} ms",irCommand,irTransmitTime)
                    postIrCommandToItemWithLockAndWait.apply(LOGGER, IR_MAPFILE, irCommand, g_computerRoomLockIrCommands, irTransmitTime, IrBlasterItem)
                    */
                    transmitIrCommand.apply(LOGGER, "CONTROL_AUDIO_POWER_TOGGLE", g_computerRoomLockIrCommands, irCommandsMap, IrBlasterItem)

                } catch(Throwable t) {
                    logError(LOGGER, "Exception caught when attempting enable receiver power. Exception was: {}", t.toString())
                } finally {
                    g_computerRoomLockReceiverUpdates.unlock()
                }

            }
            case CONTROL_AUDIO_POWER_OFF: {
                logInfo(LOGGER, "Audio control received power OFF command.")
                g_computerRoomLockReceiverUpdates.lock()
                try {
                    // Wallplug: Toggle power receiver
                    ReceiverWallplugItem.sendCommand(OnOffType::OFF)
                    Thread::sleep(2500)
                    ReceiverWallplugItem.sendCommand(OnOffType::ON)
                    Thread::sleep(1000)
                } catch(Throwable t) {
                    logError(LOGGER, "Exception caught when attempting to toggle receiver power. Exception was: {}", t.toString())
                } finally {
                    g_computerRoomLockReceiverUpdates.unlock()
                }
            }
            default: {
                logInfo(LOGGER, "Audio control received IR command {}.", receivedCommand)
                g_computerRoomLockReceiverUpdates.lock()
                try {
                    /*
                    val HashMap<String,String> irCommandDef = new HashMap<String,String>(irCommandsMap.get(receivedCommand))
                    val String irCommand = getIrCommandFromDef.apply(irCommandDef)
                    val Integer irTransmitTime = getIrTransmitTimeFromDef.apply(irCommandDef)
                    logInfo(LOGGER, "Audio command code {} corresponds to ir command named {} with transmit time of {} ms",receivedCommand,irCommand,irTransmitTime)
                    postIrCommandToItemWithLockAndWait.apply(LOGGER, IR_MAPFILE, irCommand, g_computerRoomLockIrCommands, irTransmitTime, IrBlasterItem)
                    */
                    transmitIrCommand.apply(LOGGER, receivedCommand, g_computerRoomLockIrCommands, irCommandsMap, IrBlasterItem)
                } catch(Throwable t) {
                    logError(LOGGER, "Exception caught when handling control command. The exception was: {}", t.toString())
                } finally {
                    g_computerRoomLockReceiverUpdates.unlock()
                }
            }
        }

        // To prevent the UI showing button in "pressed" state
        ControlItem.postUpdate(CONTROL_NOCHANGE)
    }
end

